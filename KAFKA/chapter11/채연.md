# 11. 보안
- 인증(Authentication): 사용자가 **누구**인지 식별
- 인가(Authorization): 사용자가 **무엇**을 할 수 있는지
- 암호화(Encryption): 누설과 위조로부터 데이터를 보호
- 감사(Auditing): 사용자가 무엇을 했는지, 하려 했는지를 추적
- 쿼터(Quotas): 자원을 얼마나 많이 사용할 수 있는지를 조절
## 안전한 카프카 클러스터의 특징
1. 클라이언트 진정성
2. 서버 진정성
3. 기밀성
4. 무결성
5. 접근제어
6. 감사 가능성
7. 가용성
## 보안 프로토콜
카프카 브로커에는 1개 이상의 엔드포인트를 가진 리스너 설정이 있다. 각각의 리스너는 가자의 보안 설정을 가질 수 있음
- TLS(SSL)
- SASL
을 조합해서 4개의 보안 프로토콜을 지원함
1. PLAINTEXT: 인증 존재 X
2. SSL: SSL 전송 계층은 선택적으로 클라이언트 SSL 인증을 수행할 수 있다. 안전하지 않은 네트워크에서 적절함
3. SASL_PLAINTEXT: SASL 인증 + PLAINTEXT 전송 계층, 사설 네트워크 안에서만 적합
4. SASL_SS: SASL 인증 + SSL 전송 계층, 안전하지 않은 네트워크에서 적합
## SASL? SSL?
SSL은 암호화하는것이 목표이고, SASL은 인증에 대한 프로토콜이다.
- SSL: 공개 키 암호화를 사용한 통신 프로토콜
- SASL: 종단간에 사용할 인증 방식을 서로 합이할 수 있도록 해주는 프로토콜
> SSL은 어느정도 인증기능도 있다?
클라이언트간에는 서로 다른 인증서를 발급해서 사용하므로 서버 입장에서는 인증서를 확인하는 순간 클라이언트가 누구인지 알 수 있다.
## 인증
- 카프카에서는 클라이언트의 신원을 나타내기 위해 KafkaPrincipal 객체를 사용함
- 자원에 대한 접근을 허가하거나 해당 클라이언트에 쿼터를 할당하는 데도 이 객체를 사용
### SSL
- TLS를 통해 연결이 생성될 경우, TLS 핸드셰이크 과정에서 인증, 암호화 매개변수 교환, 암호화를 위한 공유 키 생성 등이 처리됨
- SSL를 사용한 클라이언트 인증 기능이 활성화되어 있다면 서버 역시 클라이언트의 디지털 인증서를 검증해서 신원을 확인함
- SSL을 통한 모든 트래픽은 암호화되기 때문에 안전하지 못한 네트워크에 적절
> SSL 채널을 암호화되기 때문에 CPU 사용에 오버헤드를 초래함. SSL에서의 제로카피 전송은 현재 지원되지 않음
1. TLS 설정
- 브로커에 비밀키와 인증서를 포함하고 있는 키스토어 설정, 클라이언트에는 브로커의 인증서 혹은 브로커 인증서에 서명한 인증기관의 인증서를 포함하는 트러스트스토어가 설정되어야 함
- 브로커 간의 통신에 SSL을 사용하려 한다면 브로커의 트러스트스토어는 클라이언트 인증서의 인증기관 인증서와, 브로커 인증서의 인증기관 인증서를 모두 포함함(브로커가 클라이언트가 될 수 있기 때문)
- 인증서가 만료되기 전 키스토어와 트러스트스토어를 주기적으로 갱신해야함
2. 고려 사항
- 비밀 키를 저장하는 키스토어는 기본적으로 파일시스템상에 저장되도록 되어 있으므로, 파일시스템 권한을 사용해서 키스토어 파일에 접근할 수 있는 권한을 제한해줄 필요가 있음
- TLS 핸드셰이크는 자원을 많이 잡아먹는 데다가 브로커의 네트워크 스레드에 대해 상당한 시간을 사용함
### SASL
SASL 인증은 서버가 챌린지를 내놓으면 클라이언트가 여기에 응답을 보내는 과정을 일정한 순서로 수행하는 식으로 수행됨
## 재인증
카프카 브로커는 `connections.max.reauth.ms` 설정 옵션을 사용해서 SASL로 인증된 연결을 재인증할 수 있도록 한다.
그 값으로 세션 수명을 체크해, 이기간 동안 재인증을 하지 않은 연결은 브로커가 강제로 종료함
## 암호화
데이터의 기밀성과 무결성을 보장하기 위해 사용
- 카프카 리스너는 전송 계층으로 TLS를 사용함으로써 전송 계층 암호화를 사용할 수 있게 해줌
- 전송 계층 암호화나 데이터 저장소 암호화 정도로 충분하지만, 플랫폼 운영자나 클라우드 제공자도 접근할 수 없도록 할 필요가 있다면 전체 데이터 흐름이 암호화되는 종단 암호화를 구현하기 위해 카프카 클라이언트에 플러그인 형태로 암호화 제공자를 설정할 수 있음
> 대부분의 경우 메시지 키는 암호화를 필요로 하지 않지만, 필요한 경우 해시 동등성을 유지해야함
키값의 원본 해시값을 메시지 키에 저장하고 암호화된 키 값은 메시지 밸류 혹은 헤더에 저장하고 프로듀서 인터셉터를 사용하는 방법도 있음
## 인가
카프카 브로커는 커스터마이즈가 가능한 권한 부여자를 사용해서 접근 제어를 관리함
- AclAuthorizer는 ACL을 사용해서 카프카 자원에 대한 접근을 세밀하게 제어할 수 있도록 해줌
  - 주키퍼에 저장됨, 요청을 빠르게 인가할 수 있게 하기 위해 모든 브로커의 메모리에 캐시됨
- 고려 사항
  - AclAuthorizer가 ACL을 주키퍼에 저장하기 때문에 안전한 주키퍼를 사용할 수 없는 환경에서는 ACL을 아넞ㄴ한 외부 데이터베이스에 저장하는 커스텀 권한 관리자를 구현할 수 있음
## 감사
감사와 디버깅을 목적으로 상세한 log4j 로그를 생성하도록 카프카 브로커를 설정할 수 있음
